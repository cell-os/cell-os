#!/bin/bash

# get the absolute path of the executable
SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")
# resolve symlinks
while [ -h $SELF_PATH ]; do
  # 1) cd to directory of the symlink
  # 2) cd to the directory of where the symlink points
  # 3) get the pwd
  # 4) append the basename
  DIR=$(dirname -- "$SELF_PATH")
  SYM=$(readlink $SELF_PATH)
  SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
done
DIR=$(dirname $SELF_PATH)
# cell-os cli
type aws >/dev/null 2>&1 || { echo >&2 "AWS CLI not found
pip install awscli or brew install awscli
see http://docs.aws.amazon.com/cli/latest/userguide/installing.html"; exit 1;}

SAASBASE_ACCESS_KEY_ID='XXXXXXXXXXXXXXXXXXXX'
SAASBASE_SECRET_ACCESS_KEY='xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
AWS_OPTIONS='--output text'
PROXY_PORT=${PROXY_PORT:-'1234'}
SSH_TIMEOUT=${SSH_TIMEOUT:-'5'}
VERSION=${VERSION:-$(cat VERSION)}
SSH_USER=${SSH_USER:-'centos'} # used to login on instances, specific to VM image
USAGE="
  cell-os cli utility ${VERSION}

  usage: ./cell <action> <cell-name> [nucleus|stateless-body|stateful-body|membrane] [<index>] [<command>]
   actions:
     create <cell-name> - creates a new cell
     delete <cell-name> - deletes an existing cell
     list <cell-name> - lists existing stacks or the nodes in a cell
     scale <cell-name> <role> <capacity> - scales role to desired capacity
     ssh <cell-name> <role> [<index>] - ssh to first node in role or to index
     log <cell-name> [<role>] [<index>] - tail stack events or nodes deploy log
     cmd <cell-name> <role> <index> - run command on node n
     proxy <cell-name> <role> - open SOCKS proxy to first node in <role>

  Environment variables:

    AWS_KEY_PAIR - EC2 ssh keypir to use (defaults to first on the account)
    KEYPATH - the local path where <keypair>.pem is found (defaults to
      ${HOME}/.ssh). The .pem extension is required.
    PROXY_PORT - the SOCKS5 proxy port (defaults to ${PROXY_PORT})

usage: ./cell <action> <cell-name> [nucleus|stateless-body|stateful-body|membrane] [<index>] [<command>]
  actions:
    create <cell-name> - creates a new cell
    delete <cell-name> - deletes an existing cell
    list <cell-name> - lists existing stacks or the nodes in a cell
    scale <cell-name> <role> <capacity> - scales role to desired capacity
    ssh <cell-name> <role> [<index>] - ssh to first node in role or to index
    i2ssh <cell-name> <role> - ssh to all nodes  (requires i2cssh)
    log <cell-name> [<role>] [<index>] - tail stack events or nodes deploy log
    cmd <cell-name> <role> <index> - run command on node n
    proxy <cell-name> <role> - open SOCKS proxy to first node in <role>

  This CLI is a convenience tool, not intended as an exhaustive cluster manager.
  For advanced use-cases please use the AWS CLI or the AWS web console.

  For additional help use dl-metal-cell-users@adobe.com.
  For development related questions use dl-metal-cell-dev@adobe.com
  Github git.corp.adobe.com/metal-cell/cell-os
  Slack https://adobe.slack.com/messages/metal-cell/
\n"

ROLES="nucleus, stateless-body, stateful-body, membrane"

# action
case "$1" in
  create)
    action="create"
    ;;
  delete)
    action="delete"
    ;;
  list)
    action="list"
    ;;
  scale)
    action="scale"
    ;;
  sshall)
    action="sshall"
    ;;
  ssh)
    action="ssh"
    ;;
  log)
    action="log"
    ;;
  cmd)
    action="cmd"
    ;;
  proxy)
    action="proxy"
    ;;
  help)
    printf "${USAGE}"
    exit 0
    ;;
  *)
  echo "error: invalid action $1"
  VALIDATION_ERROR=true
esac

# cell name
if [[ ! "${action}" == "list" && -z "$2" ]]; then
  echo "error cell_name can't be empty"
  VALIDATION_ERROR=true
fi
cell_name=$2

# Try to get some defaults from the current account if values not set
AWS_KEY_PAIR=${AWS_KEY_PAIR:-$(aws ${AWS_OPTIONS} ec2 describe-key-pairs \
  --query 'KeyPairs[0].KeyName')}

# Validate values
if ! [[ $(aws ${AWS_OPTIONS} ec2 describe-key-pairs \
  | grep ${AWS_KEY_PAIR} \
  | wc -l) -gt 0 ]]; then
  echo "error: AWS_KEY_PAIR ${AWS_KEY_PAIR} doesn\'t exist."
  VALIDATION_ERROR=true
fi

bucket_name="cell-os--${cell_name}"
stack_name="${cell_name}" # TODO stack name should read selected region

CONFIG="
  \n  AWS_KEY_PAIR  = \"${AWS_KEY_PAIR}\" - defaults to first key pair on the \
                      account \
  \n  BUCKET_NAME   = \"${bucket_name}\" (readonly - cell-os--<cell-name>) \
  \n  STACK_NAME    = \"${stack_name}\" (readonly - <cell-name>) \n\n"

if [[ "${VALIDATION_ERROR}" == true ]]; then
  printf "${CONFIG}"
  exit 1
fi

if [[ "${action}" == "delete" ]]; then
  echo "WARNING: THIS WILL DELETE ALL RESOURCES ASSOCIATED TO ${cell_name}"
  echo "s3://${bucket_name}"
  aws s3 ls --summarize s3://${bucket_name}
  echo "for verification please type the name of the cell you want to delete"
  read cell_to_delete
  if [[ "${cell_to_delete}" != "${cell_name}" ]]; then
    echo "cell name doesn't match cell to delete" #1>&2
    exit 1
  fi
  aws cloudformation delete-stack --stack-name ${stack_name}
  aws s3 rm --recursive --include "*" s3://${bucket_name}
  aws s3 rb s3://${bucket_name}
  exit 0
fi

if [[ "${action}" == "list" ]]; then
    if [[ -z $2 ]]; then
      aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE \
        CREATE_IN_PROGRESS UPDATE_COMPLETE UPDATE_IN_PROGRESS \
        DELETE_IN_PROGRESS --output table \
        --query 'StackSummaries[*].[StackName,StackStatus,Tags]'
    else
      echo "[load balancers]"
      aws elb describe-load-balancers \
        --query 'LoadBalancerDescriptions[*].[LoadBalancerName, DNSName]' \
        --output table \
        | grep "${cell_name}"

      command="aws ${AWS_OPTIONS} ec2 describe-instances --query \
                'Reservations[*].Instances[*].[PublicIpAddress, \
                PrivateIpAddress, ImageId, State.Name, KeyName]' \
                --filters Name=tag:cell,Values=$2 \
                Name=instance-state-name,Values=*ing \
                --output text"
      echo "[nucleus]"
      sh -c "${command} Name=tag:role,Values=nucleus"
      echo "[stateless-body]"
      sh -c "${command} Name=tag:role,Values=stateless-body"
      echo "[stateful-body]"
      sh -c "${command} Name=tag:role,Values=stateful-body"
      echo "[membrane]"
      sh -c "${command} Name=tag:role,Values=membrane"
    fi
    exit 0
fi

if [[ "${action}" == "scale" ]]; then
  if ! [[ $3 == "nucleus" || $3 == "stateless-body" || $3 == "stateful-body" || $3 == "membrane"  ]]; then
    echo "please provide role (${ROLES})" >&2
    exit 0
  fi
  role=$3
  desired_capacity=$4
  if ! [[ ${desired_capacity} -eq ${desired_capacity} ]]; then
    echo desired_capacity must be an integer >&2
    exit 1
  fi
  # --filter or --filters doesn't seem to be working
  # alternatively this could be done through --query
  scaling_group=$(aws autoscaling describe-auto-scaling-groups --query \
    'AutoScalingGroups[*].[AutoScalingGroupName]' \
    | grep "${cell_name}" \
    | grep -i "${role}")
 echo "Scaling group ${scaling_group}"
 result=$(aws autoscaling update-auto-scaling-group --auto-scaling-group-name \
   ${scaling_group} --desired-capacity ${desired_capacity})
 exit
fi

if [[ "${action}" == "sshall" ]]; then
  ssh_options="-o ConnectTimeout=${SSH_TIMEOUT}"
  machines=$(for role in nucleus stateful-body membrane stateless-body; do 
    aws ${AWS_OPTIONS} ec2 describe-instances \
      --query 'Reservations[*].Instances[*].[PublicIpAddress]' \
      --filters Name=instance-state-code,Values=16 \
      Name=tag:cell,Values=${cell_name} Name=tag:role,Values=${role} 
  done | sed 's/$/,/g' | tr -d "\n" | sed 's/,$//g')

  key_file=${KEYPATH:-"${HOME}/.ssh"}/${AWS_KEY_PAIR}.pem
  if ! [[ -e "${key_file}" ]]; then
    echo "can't find ${key_file}. Set your KEYPATH env var to the .pem location"
    exit 1
  fi
  i2cssh -l ${SSH_USER} -m $machines -Xi="${key_file}"

fi

if [[ "${action}" == "ssh" || "${action}" == "log" || "${action}" == "cmd" 
  || "${action}" == "proxy" ]]; then

  command=$5
  if [[ "${action}" == "log" ]]; then
    if [[ -z $3 ]]; then
      watch -n 1 "aws cloudformation describe-stack-events \
        --stack-name ${stack_name} --output table \
        --query 'StackEvents[*].[Timestamp, LogicalResourceId, ResourceStatus]' \
        --max-items 10"
      exit 0
    fi
    command="tail -f /var/log/cloud-init.log"
  fi

  ssh_options="-o ConnectTimeout=${SSH_TIMEOUT}"
  if [[ "${action}" == "proxy" ]]; then
    ssh_options="${ssh_options} -D ${PROXY_PORT}"
  fi

  if ! [[ $3 == "nucleus" || $3 == "stateless-body" || $3 == "stateful-body" || $3 == "membrane"  ]]; then
    echo "please provide role (${ROLES})" >&2
    exit 0
  fi
  role=$3

  index=$4
  if [[ -z "${index}" || -n "${index//[0-9]/}" ]]; then
    index=1
  fi

  ip_and_keypair=$(aws ${AWS_OPTIONS} ec2 describe-instances \
    --query 'Reservations[*].Instances[*].[PublicIpAddress, KeyName]' \
    --filters Name=instance-state-code,Values=16 \
    Name=tag:cell,Values=${cell_name} Name=tag:role,Values=${role} \
    | sed -n "${index} p")
  if [[ "${ip_and_keypair}" == "None" || -z "${ip_and_keypair}" ]]; then
    echo "can't find node ${index} in ${role} yet. Is the cell fully up?"
    exit 1
  fi

  if [[ "${action}" == "cmd" ]]; then
    if [[ -z $5 ]]; then
      echo "command can't be empty"
      printf "${USAGE}"
      exit 1
    fi
    # allocate tty
    ssh_options="$ssh_options -t"
  fi

  ip=$( echo "${ip_and_keypair}" | cut -d$'\t' -f1 )
  keypair=$( echo "${ip_and_keypair}" | cut -d$'\t' -f2 )

  printf "ip=${ip} \nkeypair=${keypair} \ncommand=${command}"
  key_file=${KEYPATH:-"${HOME}/.ssh"}/${keypair}.pem
  if ! [[ -e "${key_file}" ]]; then
    echo "can't find ${key_file}. Set your KEYPATH env var to the .pem location"
    exit 1
  fi
  ssh ${ssh_options} "${SSH_USER}@${ip}" -i "${key_file}" "${command}"
  exit
fi

if [[ "${action}" == "create" ]]; then
  if [[ $GENERATE ]]; then
    echo "creating stacks"
    python $DIR/deploy/aws/tools/elastic-cell.py > $DIR/deploy/aws/tools/elastic-cell.json
    python $DIR/deploy/aws/tools/elastic-cell-scaling-group.py > $DIR/deploy/aws/tools/elastic-cell-scaling-group.json
    
    base_stack=$DIR/deploy/aws/tools/elastic-cell.json
    sub_stack=$DIR/deploy/aws/tools/elastic-cell-scaling-group.json
  else
    base_stack=$DIR/deploy/aws/elastic-cell.json
    sub_stack=$DIR/deploy/aws/elastic-cell-scaling-group.json
  fi
  echo "creating s3 bucket s3://${bucket_name}"
  RET=$({ aws s3 mb "s3://${bucket_name}" ;} 2>&1)
  create_error=$?
  echo ${RET} | grep AlreadyOwnedByYou > /dev/null
  already_owned=$?

  if [[ ! ${create_error} -eq 0 && ! ${already_owned} -eq 0 ]]; then
    echo ${RET}
    exit 1
  fi

  # Copy nested stack
  RET=$(aws s3 cp $sub_stack s3://"${bucket_name}"/)
  if [[ ! $? -eq 0 ]]; then
    exit 1
  fi

  echo "creating stack ${stack_name}..."
  aws cloudformation create-stack \
      --template-body "file://${base_stack}" \
      --stack-name "${stack_name}" \
      --tags Key=name,Value="${cell_name}" Key=version,Value="${VERSION}" \
      --capabilities CAPABILITY_IAM \
      --parameters \
          ${extra_parameters} \
          ParameterKey=CellName,ParameterValue="${cell_name}" \
          ParameterKey=CellOsVersionBundle,ParameterValue="cell-os-base-${VERSION}" \
          ParameterKey=KeyName,ParameterValue="${AWS_KEY_PAIR}" \
          ParameterKey=BucketName,ParameterValue="${bucket_name}" \
          ParameterKey=SaasBaseAccessKeyId,ParameterValue="${SAASBASE_ACCESS_KEY_ID}" \
          ParameterKey=SaasBaseSecretAccessKey,ParameterValue="${SAASBASE_SECRET_ACCESS_KEY}" \
  || { exit 1; }

  echo "cloudformation ret = $?"
  printf "${CONFIG}"

  echo "To watch your cell infrastructure provisioning log you can ./cell log ${cell_name}" 
  echo "For detailed node provisioning ./cell log ${cell_name} nucleus 1"
fi
