#!/bin/bash

# get the absolute path of the executable
SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")
# resolve symlinks
while [ -h $SELF_PATH ]; do
  # 1) cd to directory of the symlink
  # 2) cd to the directory of where the symlink points
  # 3) get the pwd
  # 4) append the basename
  DIR=$(dirname -- "$SELF_PATH")
  SYM=$(readlink $SELF_PATH)
  SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
done
DIR=$(dirname $SELF_PATH)
# cell-os cli
type aws >/dev/null 2>&1 || {
  cat >&2 <<EOD
AWS CLI not found
pip install awscli or brew install awscli
see http://docs.aws.amazon.com/cli/latest/userguide/installing.html
EOD

exit 1
}

SAASBASE_ACCESS_KEY_ID="${SAASBASE_ACCESS_KEY_ID:-XXXXXXXXXXXXXXXXXXXX}"
SAASBASE_SECRET_ACCESS_KEY="${SAASBASE_SECRET_ACCESS_KEY:-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}"
AWS_OPTIONS='--output text'
PROXY_PORT=${PROXY_PORT:-'1234'}
SSH_TIMEOUT=${SSH_TIMEOUT:-'5'}
VERSION=${VERSION:-$(cat VERSION)}
SSH_USER=${SSH_USER:-'centos'} # used to login on instances, specific to VM image
# Try to get some defaults from the current account if values not set
AWS_KEY_PAIR=${AWS_KEY_PAIR:-$(aws ${AWS_OPTIONS} ec2 describe-key-pairs --query 'KeyPairs[0].KeyName')}

usage() {
cat >&2 <<EOD

cell-os cli utility ${VERSION}

usage: ./cell <action> <cell-name> [nucleus|stateless-body|stateful-body|membrane] [<index>] [<command>]
  actions:
    create <cell-name> - creates a new cell
    delete <cell-name> - deletes an existing cell
    list <cell-name> - lists existing stacks or the nodes in a cell
    scale <cell-name> <role> <capacity> - scales role to desired capacity
    ssh <cell-name> <role> [<index>] - ssh to first node in role or to index
    log <cell-name> [<role>] [<index>] - tail stack events or nodes deploy log
    cmd <cell-name> <role> <index> - run command on node n
    proxy <cell-name> <role> - open SOCKS proxy to first node in <role>

Environment variables:

  AWS_KEY_PAIR - EC2 ssh keypir to use (defaults to first on the account)
  KEYPATH - the local path where <keypair>.pem is found (defaults to
    ${HOME}/.ssh). The .pem extension is required.
  PROXY_PORT - the SOCKS5 proxy port (defaults to ${PROXY_PORT})

All AWS CLI environment variables (e.g. AWS_DEFAULT_REGION, AWS_ACCESS_KEY_ID,
AWS_SECRET_ACCESS_KEY, etc.) and configs apply.

This CLI is a convenience tool, not intended as an exhaustive cluster manager.
For advanced use-cases please use the AWS CLI or the AWS web console.

For additional help use dl-metal-cell-users@adobe.com.
For development related questions use dl-metal-cell-dev@adobe.com
Github git.corp.adobe.com/metal-cell/cell-os
Slack https://adobe.slack.com/messages/metal-cell/

EOD
}

ROLES="nucleus, stateless-body, stateful-body, membrane"

parse_args() {
  [[ ! -z $1 ]] && action=$1
  [[ ! -z $2 ]] && cell_name=$2
  [[ ! -z $3 ]] && role=$3
  [[ ! -z $4 ]] && index=$4
  [[ ! -z $4 ]] && capacity=$4
  bucket_name="cell-os--${cell_name}"
  stack_name="${cell_name}" # TODO stack name should read selected region
}

check_cell_name() {
  if [[ -z "$cell_name" ]]; then
    echo "error: cell_name can't be empty"
    VALIDATION_ERROR=true
    return 1
  fi
  return 0
}

check_key_pair() {
  if ! [[ $(aws ${AWS_OPTIONS} ec2 describe-key-pairs | grep ${AWS_KEY_PAIR} | wc -l) -gt 0 ]]; then
    echo "error: AWS_KEY_PAIR ${AWS_KEY_PAIR} doesn\'t exist."
    VALIDATION_ERROR=true
    return 1
  fi
  return 0
}

check_role() {
  if ! [[ $role == "nucleus" || $role == "stateless-body" || $role == "stateful-body" || $role == "membrane"  ]]; then
    echo "please provide role (${ROLES})" >&2
    exit 1
  fi
}

cfn() {
  aws cloudformation ${1}-stack \
      --template-body "file://${base_stack}" \
      --stack-name "${stack_name}" \
      --tags Key=name,Value="${cell_name}" Key=version,Value="${VERSION}" \
      --capabilities CAPABILITY_IAM \
      --parameters \
          ${extra_parameters} \
          ParameterKey=CellName,ParameterValue="${cell_name}" \
          ParameterKey=CellOsVersionBundle,ParameterValue="cell-os-base-${VERSION}" \
          ParameterKey=KeyName,ParameterValue="${AWS_KEY_PAIR}" \
          ParameterKey=BucketName,ParameterValue="${bucket_name}" \
          ParameterKey=SaasBaseAccessKeyId,ParameterValue="${SAASBASE_ACCESS_KEY_ID}" \
          ParameterKey=SaasBaseSecretAccessKey,ParameterValue="${SAASBASE_SECRET_ACCESS_KEY}" \
  || { exit 1; }
}

build_stack_files() {
  if [[ $GENERATE ]]; then
    echo "creating stacks"
    python $DIR/deploy/aws/tools/elastic-cell.py > $DIR/deploy/aws/tools/elastic-cell.json
    python $DIR/deploy/aws/tools/elastic-cell-scaling-group.py > $DIR/deploy/aws/tools/elastic-cell-scaling-group.json
    
    base_stack=$DIR/deploy/aws/tools/elastic-cell.json
    sub_stack=$DIR/deploy/aws/tools/elastic-cell-scaling-group.json
  else
    base_stack=$DIR/deploy/aws/elastic-cell.json
    sub_stack=$DIR/deploy/aws/elastic-cell-scaling-group.json
  fi
}

create_bucket() {
  echo "creating s3 bucket s3://${bucket_name}"
  ret=$({ aws s3 mb "s3://${bucket_name}" ;} 2>&1)
  create_error=$?
  echo ${ret} | grep AlreadyOwnedByYou > /dev/null
  already_owned=$?

  if [[ ! ${create_error} -eq 0 && ! ${already_owned} -eq 0 ]]; then
    echo ${ret}
    exit 1
  fi
}

copy_to_bucket() {
  echo "copy stack to S3://${bucket_name}"
  ret=$(aws s3 cp ${sub_stack} s3://"${bucket_name}"/)
  if [[ ! $? -eq 0 ]]; then
    exit 1
  fi
}

update() {
  [[ check_cell_name ]] || return 1
  [[ check_key_pair ]] || return 1

  build_stack_files

  copy_to_bucket

  echo "creating stack ${stack_name}..."
  cfn update

  echo "cloudformation ret = $?"
  printf "${CONFIG}"

  echo "To watch your cell infrastructure provisioning log you can ./cell log ${cell_name}" 
  echo "For detailed node provisioning ./cell log ${cell_name} nucleus 1"
  exit 0
}

create() {
  [[ check_cell_name ]] || return 1
  [[ check_key_pair ]] || return 1

  build_stack_files

  create_bucket

  copy_to_bucket

  echo "creating stack ${stack_name}..."
  cfn create

  echo "cloudformation ret = $?"
  printf "${CONFIG}"

  echo "To watch your cell infrastructure provisioning log you can ./cell log ${cell_name}" 
  echo "For detailed node provisioning ./cell log ${cell_name} nucleus 1"
  exit 0
}

delete() {
  [[ check_cell_name ]] || return 1
  echo "WARNING: THIS WILL DELETE ALL RESOURCES ASSOCIATED TO ${cell_name}"
  echo "s3://${bucket_name}"
  aws s3 ls --summarize s3://${bucket_name}
  echo "for verification please type the name of the cell you want to delete"
  read cell_to_delete
  if [[ "${cell_to_delete}" != "${cell_name}" ]]; then
    echo "cell name doesn't match cell to delete" #1>&2
    exit 1
  fi
  aws cloudformation delete-stack --stack-name ${stack_name}
  aws s3 rm --recursive --include "*" s3://${bucket_name}
  aws s3 rb s3://${bucket_name}
  exit 0
}

list() {
  if [[ -z $cell_name ]]; then
    aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE \
      CREATE_IN_PROGRESS UPDATE_COMPLETE UPDATE_IN_PROGRESS \
      DELETE_IN_PROGRESS --output table \
      --query 'StackSummaries[*].[StackName,StackStatus,Tags]'
  else
    echo "[load balancers]"
    aws elb describe-load-balancers \
      --query 'LoadBalancerDescriptions[*].[LoadBalancerName, DNSName]' \
      --output table \
      | grep "${cell_name}"

    describe_command="aws ${AWS_OPTIONS} ec2 describe-instances --query \
              'Reservations[*].Instances[*].[PublicIpAddress, \
              PrivateIpAddress, ImageId, State.Name, KeyName]' \
              --filters Name=tag:cell,Values=$cell_name \
              Name=instance-state-name,Values=*ing \
              --output text"
    echo "[nucleus]"
    sh -c "${describe_command} Name=tag:role,Values=nucleus"
    echo "[stateless-body]"
    sh -c "${describe_command} Name=tag:role,Values=stateless-body"
    echo "[stateful-body]"
    sh -c "${describe_command} Name=tag:role,Values=stateful-body"
    echo "[membrane]"
    sh -c "${describe_command} Name=tag:role,Values=membrane"
  fi
  exit 0
}

scale() {
  check_role
  if ! [[ ${capacity} -eq ${capacity} ]]; then
    echo capacity must be an integer >&2
    exit 1
  fi
  # jmespath outputs some trash which we need to filter out
  scaling_group=$(aws autoscaling describe-auto-scaling-groups --output text \
    --query "AutoScalingGroups[? (Tags[? Key=='role' && Value=='${role}'] \
    && Tags[?Key=='cell' && Value=='${cell_name}'])]\
    .AutoScalingGroupName")
  echo "Scaling ${cell_name}.${role}(${scaling_group}) to ${capacity}"
  result=$(aws autoscaling update-auto-scaling-group --auto-scaling-group-name \
    ${scaling_group} --desired-capacity ${capacity})
  echo "${result}"
exit
}

cell_ssh() {
  check_role

  ssh_options="${1} -o ConnectTimeout=${SSH_TIMEOUT}"
  if [[ -z "${index}" || -n "${index//[0-9]/}" ]]; then
    index=1
  fi
  ip_and_keypair=$(aws ${AWS_OPTIONS} ec2 describe-instances \
    --query 'Reservations[*].Instances[*].[PublicIpAddress, KeyName]' \
    --filters Name=instance-state-code,Values=16 \
    Name=tag:cell,Values=${cell_name} Name=tag:role,Values=${role} \
    | sed -n "${index} p")
  if [[ "${ip_and_keypair}" == "None" || -z "${ip_and_keypair}" ]]; then
    echo "can't find node ${index} in ${role} yet. Is the cell fully up?"
    exit 1
  fi
  ip=$( echo "${ip_and_keypair}" | cut -d$'\t' -f1 )
  keypair=$( echo "${ip_and_keypair}" | cut -d$'\t' -f2 )
  printf "ip=${ip} \nkeypair=${keypair} \ncommand=${2:-}\n"
  key_file=${KEYPATH:-"${HOME}/.ssh"}/${keypair}.pem
  if ! [[ -e "${key_file}" ]]; then
    echo "can't find ${key_file}. Set your KEYPATH env var to the .pem location"
    exit 1
  fi
  ssh ${ssh_options} "${SSH_USER}@${ip}" -i "${key_file}" "${2:-}"
}

log() {
  [[ check_cell_name ]] || return 1
  if [[ -z $role ]]; then
    watch -n 1 "aws cloudformation describe-stack-events \
      --stack-name ${stack_name} --output table \
      --query 'StackEvents[*].[Timestamp, LogicalResourceId, ResourceStatus]' \
      --max-items 10"
    exit 0
  else
    check_role
    command="tail -f /var/log/cloud-init.log"

    cell_ssh "" "$command"
  fi
}

cmd() {
  if [[ -z $5 ]]; then
    echo "command can't be empty"
    printf "${USAGE}"
    exit 1
  fi
  cell_ssh "-t" "$5"
}

proxy() {
  pgrep -f -- "-N -g -C -D ${PROXY_PORT}" | xargs kill -9
  cell_ssh "-N -g -C -D ${PROXY_PORT}" ""
}

i2cssh() {
  ssh_options="-o ConnectTimeout=${SSH_TIMEOUT}"
  machines=$(for role in nucleus stateful-body membrane stateless-body; do 
    aws ${AWS_OPTIONS} ec2 describe-instances \
      --query 'Reservations[*].Instances[*].[PublicIpAddress]' \
      --filters Name=instance-state-code,Values=16 \
      Name=tag:cell,Values=${cell_name} Name=tag:role,Values=${role} 
  done | sed 's/$/,/g' | tr -d "\n" | sed 's/,$//g')

  key_file=${KEYPATH:-"${HOME}/.ssh"}/${AWS_KEY_PAIR}.pem
  if ! [[ -e "${key_file}" ]]; then
    echo "can't find ${key_file}. Set your KEYPATH env var to the .pem location"
    exit 1
  fi
  i2cssh -l ${SSH_USER} -m $machines -Xi="${key_file}"
}

parse_args "$@"

read -r -d '' CONFIG << EOM
  AWS_KEY_PAIR  = "${AWS_KEY_PAIR}" - defaults to first key pair on the account
  BUCKET_NAME   = "${bucket_name}" (readonly - cell-os--<cell-name>)
  STACK_NAME    = "${stack_name}" (readonly - <cell-name>)
EOM

# action
case "$1" in
  create)
    create
    ;;
  update)
    update
    ;;
  delete)
    delete
    ;;
  list)
    list
    ;;
  scale)
    scale
    ;;
  i2cssh)
    i2cssh
    ;;
  ssh)
    cell_ssh
    ;;
  log)
    log
    ;;
  cmd)
    cmd "$@"
    ;;
  proxy)
    proxy
    ;;
  help)
    usage
    exit 0
    ;;
  *)
  echo "error: invalid action $1"
  VALIDATION_ERROR=true
esac

if [[ "${VALIDATION_ERROR}" == true ]]; then
  printf "${CONFIG}"
  exit 1
fi

