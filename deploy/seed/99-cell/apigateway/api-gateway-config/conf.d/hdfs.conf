server {
  listen 80;
  server_name ~^hdfs.(api|gw)\.(?<domain>.+);
  set $hdfs_http_port 50070;
  set_by_lua $hdfs_nn1 'return os.getenv("HDFS_NN1_HOST") or "10.255.255.2"';
  set_by_lua $hdfs_nn2 'return os.getenv("HDFS_NN2_HOST") or "10.255.255.2"';
  set $hdfs_active_nn $hdfs_nn1;

  include /etc/api-gateway/conf.d/includes/resolvers.conf;

  location /check_hdfs_state_nn1 {
    internal;
    proxy_method GET;
    proxy_pass_request_body off;
    proxy_pass_request_headers off;
    proxy_pass http://$hdfs_nn1:$hdfs_http_port/jmx?qry=Hadoop:service=NameNode,name=NameNodeStatus;
  }

  location / {
    if ( $is_admin_zone_ip = "0" ) {
        return 403;
    }

    rewrite_by_lua "
      local cjson = require 'cjson'

      local res = ngx.location.capture('/check_hdfs_state_nn1')
      local ok, nn1_jmx_bean = pcall(cjson.decode, res.body)
      if (not ok) then
        ngx.log(ngx.WARN, 'Could not decode HDFS response from ', tostring(ngx.var.hdfs_nn1), '. Response=', tostring(res.body))
        ngx.var.hdfs_active_nn = ngx.var.hdfs_nn2
        return
      end

      -- hdfs_state contains a piece of JMX response containing the active namenode
      if nn1_jmx_bean ~= nil and nn1_jmx_bean.beans ~= nil then
        nn1_state = nn1_jmx_bean.beans[1]
        -- nn1_state - object containing namenode state
        if nn1_state.State ~= 'active' then
          -- NOTE: at the moment when NN2 becomes unavailable the cell doesn't recover
          ngx.var.hdfs_active_nn = ngx.var.hdfs_nn2
        end
      end
    ";

    proxy_pass http://$hdfs_active_nn:$hdfs_http_port;
  }
}

